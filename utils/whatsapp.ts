import { Sale, db, User, Customer, Category, InventoryItem, clearAllData } from '../db.ts';
import pako from 'pako';
import { getShopId } from './supabase.ts';

export const formatNaira = (amount: number) => {
  return new Intl.NumberFormat('en-NG', {
    style: 'currency',
    currency: 'NGN',
    minimumFractionDigits: 0
  }).format(amount);
};

export const shareReceiptToWhatsApp = async (sale: Sale) => {
  const snSetting = await db.settings.get('shop_name');
  const saSetting = await db.settings.get('shop_address');
  
  const shopName = snSetting?.value || localStorage.getItem('shop_name') || 'NaijaShop';
  const shopInfo = saSetting?.value || localStorage.getItem('shop_info') || '';
  
  const date = new Date(sale.timestamp).toLocaleString('en-NG', {
    dateStyle: 'medium',
    timeStyle: 'short'
  });
  
  const transId = sale.id ? String(sale.id).padStart(5, '0') : 'N/A';

  let message = `üõçÔ∏è *${shopName.toUpperCase()}*\n`;
  if (shopInfo) message += `üìç ${shopInfo}\n`;
  message += `--------------------------\n`;
  message += `üìú *RECEIPT #${transId}*\n`;
  message += `üìÖ Date: ${date}\n`;
  message += `--------------------------\n`;
  message += `üì¶ *ITEMS:*\n`;
  
  sale.items.forEach(item => {
    const itemTotal = item.price * item.quantity;
    message += `‚Ä¢ ${item.name} x ${item.quantity} ... ${formatNaira(itemTotal)}\n`;
  });
  
  message += `--------------------------\n`;
  message += `üí∞ *Total Bill: ${formatNaira(sale.total)}*\n`;

  if (sale.walletUsed && sale.walletUsed > 0) {
    message += `üí≥ Paid from Wallet: -${formatNaira(sale.walletUsed)}\n`;
  }

  if (sale.cashPaid && sale.cashPaid > 0) {
    message += `üíµ Cash Paid: ${formatNaira(sale.cashPaid)}\n`;
  }
  
  if (sale.paymentMethod === 'Debt' || sale.paymentMethod === 'Partial') {
    const remainingDebt = Math.max(0, sale.total - (sale.walletUsed || 0) - (sale.cashPaid || 0));
    message += `--------------------------\n`;
    message += `‚ö†Ô∏è *BALANCE OWED (DEBT): ${formatNaira(remainingDebt)}*\n`;
    message += `üìå Status: Partially Settled\n`;
  } else {
    const totalPayment = (sale.walletUsed || 0) + (sale.cashPaid || 0);
    message += `--------------------------\n`;
    message += `‚úÖ Total Paid: ${formatNaira(totalPayment)}\n`;
  }
  
  message += `--------------------------\n`;

  if (sale.customer_phone) {
    const customer = await db.customers.where('phone').equals(sale.customer_phone).first();
    if (sale.walletSaved && sale.walletSaved > 0) {
      message += `‚ú® Change Saved to Wallet: +${formatNaira(sale.walletSaved)}\n`;
    }
    if (customer) {
      message += `üè¶ Your Wallet Balance: ${formatNaira(customer.walletBalance)}\n`;
    }
    message += `--------------------------\n`;
  }

  message += `üôè *Thank you for your business!*\n`;
  message += `\n_Generated by NaijaShop POS_ üá≥üá¨`;

  const encodedMessage = encodeURIComponent(message);
  window.open(`https://api.whatsapp.com/send?text=${encodedMessage}`, '_blank');
};

/**
 * CORE BACKUP ENGINE (GZIP)
 */
export const backupToWhatsApp = async (data: any, forceTextOnly = false): Promise<any> => {
  let finalData = { ...data };

  if (forceTextOnly) {
    if (finalData.inventory) finalData.inventory = finalData.inventory.map(({ image, ...rest }: any) => rest);
    if (finalData.categories) finalData.categories = finalData.categories.map(({ image, ...rest }: any) => rest);
  }

  finalData.type = 'MASTER_BACKUP';
  const jsonString = JSON.stringify(finalData);
  const sizeMB = jsonString.length / (1024 * 1024);

  if (sizeMB > 5 && !forceTextOnly) {
    if (confirm(`‚ö†Ô∏è LARGE BACKUP: Your shop file is ${sizeMB.toFixed(1)}MB. Use Text-Only (Fast) instead of Photos?`)) {
      return backupToWhatsApp(data, true);
    }
  }

  const timestamp = Date.now();
  const dateStr = new Date(timestamp).toISOString().split('T')[0];
  const fileName = `NAIJASHOP_MASTER_${forceTextOnly ? 'LITE_' : ''}${dateStr}.json.gz`;

  const compressed = pako.gzip(new TextEncoder().encode(jsonString));
  const blob = new Blob([compressed], { type: 'application/gzip' });
  
  if (navigator.share) {
    try {
      const file = new File([blob], fileName, { type: 'application/gzip' });
      await navigator.share({ title: `Master Backup: ${data.shopName || 'Shop'}`, files: [file] });
      await db.settings.put({ key: 'last_backup_timestamp', value: Date.now() });
      return { success: true, method: 'FILE_SHARE', fileName };
    } catch (e) { console.warn("Share failed, downloading..."); }
  }

  const url = URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = fileName;
  document.body.appendChild(anchor);
  anchor.click();
  document.body.removeChild(anchor);
  URL.revokeObjectURL(url);
  await db.settings.put({ key: 'last_backup_timestamp', value: Date.now() });
  return { success: true, method: 'DOWNLOAD', fileName };
};

/**
 * 1. BOSS -> STAFF (Push Products & Prices)
 */
export const pushInventoryUpdateToStaff = async (resetStock: boolean = false) => {
  const inventory = await db.inventory.toArray();
  const categories = await db.categories.toArray();
  const staffUsers = await db.users.where('role').equals('Staff').toArray();
  
  const sn = await db.settings.get('shop_name');
  const shopName = sn?.value || localStorage.getItem('shop_name') || 'NaijaShop';
  
  const softPosBank = (await db.settings.get('softPosBank'))?.value || '';
  const softPosNumber = (await db.settings.get('softPosNumber'))?.value || '';
  const softPosAccount = (await db.settings.get('softPosAccount'))?.value || '';

  // Inherit License Data
  const licenseExp = await db.security.get('license_expiry');
  const licenseSig = await db.security.get('license_signature');
  const trialStart = await db.settings.get('trial_start');

  const payload = {
    type: 'INVENTORY_UPDATE',
    shopName,
    timestamp: Date.now(), // Monotonic Sync Check
    inventory,
    categories,
    staffUsers,
    resetStock,
    license_expiry: licenseExp?.value,
    license_signature: licenseSig?.value,
    trial_start: trialStart?.value,
    settings: { softPosBank, softPosNumber, softPosAccount }
  };

  const jsonString = JSON.stringify(payload);
  const compressed = pako.gzip(new TextEncoder().encode(jsonString));
  const fileName = `NAIJASHOP_UPDATE_${new Date().toISOString().split('T')[0]}.json.gz`;
  const blob = new Blob([compressed], { type: 'application/gzip' });
  
  if (navigator.share) {
    try {
      const file = new File([blob], fileName, { type: 'application/gzip' });
      await navigator.share({
        title: `Shop Update: ${shopName}`,
        text: "Oga has updated prices. Import this file to sync.",
        files: [file]
      });
      return true;
    } catch (err) { console.warn("Share failed"); }
  }

  const url = URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = fileName;
  document.body.appendChild(anchor);
  anchor.click();
  document.body.removeChild(anchor);
  URL.revokeObjectURL(url);
  return true;
};

/**
 * 2. STAFF -> SYSTEM (Import Products & Prices)
 */
export const applyInventoryUpdate = async (data: any) => {
  if (data.type !== 'INVENTORY_UPDATE') throw new Error('Invalid Sync File');

  // KILL SWITCH: Check if the current logged-in staff member is still active
  const loggedInStaffName = localStorage.getItem('logged_in_staff_name');
  const deviceRole = localStorage.getItem('device_role');

  if (deviceRole === 'StaffDevice' && loggedInStaffName && data.staffUsers) {
    const staffExists = data.staffUsers.find((u: any) => u.name === loggedInStaffName);
    if (!staffExists) {
      await clearAllData();
      localStorage.clear();
      alert("‚ùå ACCESS REVOKED: You are no longer authorized to manage this shop. Data wiped.");
      window.location.href = '/';
      return { added: 0, updated: 0 };
    }
  }

  // MONOTONIC CLOCK SYNC: Detect "Time Travel" bypasses
  if (data.timestamp && Date.now() < (data.timestamp - (60 * 60 * 1000))) {
     alert("‚ö†Ô∏è CLOCK ERROR: Your phone date is incorrect. Please set your phone to the correct time to continue.");
     localStorage.setItem('license_tampered', 'true');
     window.location.reload();
     return { added: 0, updated: 0 };
  }

  let added = 0;
  let updated = 0;
  const resetStock = data.resetStock === true;

  await db.transaction('rw', [db.inventory, db.categories, db.settings, db.users, db.security], async () => {
    // 1. Sync License (Inherit from Boss)
    if (data.license_expiry && data.license_signature) {
      await db.security.put({ key: 'license_expiry', value: data.license_expiry });
      await db.security.put({ key: 'license_signature', value: data.license_signature });
      localStorage.setItem('license_expiry', data.license_expiry);
      localStorage.setItem('license_signature', data.license_signature);
      localStorage.setItem('is_activated', 'true');
      localStorage.removeItem('is_trialing');
    }
    
    if (data.trial_start) {
      await db.settings.put({ key: 'trial_start', value: data.trial_start });
      localStorage.setItem('trial_start_date', data.trial_start.toString());
    }

    // 2. Sync Soft POS Settings
    if (data.settings) {
      await db.settings.put({ key: 'softPosBank', value: data.settings.softPosBank });
      await db.settings.put({ key: 'softPosNumber', value: data.settings.softPosNumber });
      await db.settings.put({ key: 'softPosAccount', value: data.settings.softPosAccount });
    }

    // 3. Sync Categories
    if (data.categories) {
      for (const cat of data.categories) {
        const { id, ...catData } = cat;
        const exists = await db.categories.where('name').equals(cat.name).first();
        if (!exists) await db.categories.add(catData);
      }
    }

    // 4. Sync Inventory
    if (data.inventory) {
      for (const item of data.inventory) {
        const { id, stock, ...itemData } = item;
        const local = await db.inventory.where('name').equals(item.name).first();

        if (local) {
          const finalUpdate = resetStock ? { ...itemData, stock } : itemData;
          await db.inventory.update(local.id!, finalUpdate);
          updated++;
        } else {
          await db.inventory.add({ ...itemData, stock });
          added++;
        }
      }
    }
    
    // 5. Update Local Users List (Enforce Kill Switch next login)
    if (data.staffUsers) {
      await db.users.where('role').equals('Staff').delete();
      for (const u of data.staffUsers) {
        const { id, ...userData } = u;
        await db.users.add(userData);
      }
    }
  });

  localStorage.setItem('last_inventory_sync', Date.now().toString());
  return { added, updated };
};

/**
 * 3. STAFF -> BOSS (Export Sales Report)
 */
export const exportStaffSalesReport = async (sales: Sale[]) => {
  const sn = await db.settings.get('shop_name');
  const shopName = sn?.value || localStorage.getItem('shop_name') || 'NaijaShop';
  
  const startOfDay = new Date().setHours(0,0,0,0);
  const debts = await db.debts.where('date').aboveOrEqual(startOfDay).toArray();
  const customers = await db.customers.where('lastTransaction').aboveOrEqual(startOfDay).toArray();

  const payload = { 
    type: 'STAFF_REPORT',
    sales, 
    debts,
    customers,
    shopName, 
    staffName: localStorage.getItem('logged_in_staff_name') || 'Staff',
    timestamp: Date.now() 
  };

  const compressed = pako.gzip(new TextEncoder().encode(JSON.stringify(payload)));
  const fileName = `SALES_REPORT_${shopName}_${new Date().toISOString().split('T')[0]}.json.gz`;
  const blob = new Blob([compressed], { type: 'application/gzip' });

  if (navigator.share) {
    try {
      const file = new File([blob], fileName, { type: 'application/gzip' });
      await navigator.share({
        title: `Daily Report: ${shopName}`,
        text: `Oga, here is the report for today. Merge to update master inventory.`,
        files: [file]
      });
      return true;
    } catch (e) { console.error('Share failed'); }
  }

  const url = URL.createObjectURL(blob);
  const anchor = document.createElement('a');
  anchor.href = url;
  anchor.download = fileName;
  document.body.appendChild(anchor);
  anchor.click();
  document.body.removeChild(anchor);
  URL.revokeObjectURL(url);
  return true;
};

/**
 * 4. BOSS -> SYSTEM (Merge Staff Report)
 */
export const reconcileStaffSales = async (report: any, adminName: string = 'Boss') => {
  if (report.type !== 'STAFF_REPORT') throw new Error('Invalid Report File');

  let mergedSales = 0;
  let skippedSales = 0;
  let debtsMerged = 0;

  await db.transaction('rw', [db.inventory, db.sales, db.customers, db.debts, db.stock_logs], async () => {
    for (const sale of (report.sales || [])) {
      const exists = await db.sales.where('uuid').equals(sale.uuid).first();
      if (exists) {
        skippedSales++;
        continue;
      }

      for (const item of sale.items) {
        const invItem = await db.inventory.where('name').equals(item.name).first();
        if (invItem) {
          const newStock = Math.max(0, (invItem.stock || 0) - item.quantity);
          await db.inventory.update(invItem.id!, { stock: newStock });
          
          await db.stock_logs.add({
            item_id: invItem.id!,
            itemName: invItem.name,
            quantityChanged: -item.quantity,
            previousStock: invItem.stock,
            newStock: newStock,
            type: 'Sales Deduction',
            date: Date.now(),
            staff_name: `Report Merge (${report.staffName})`
          });
        }
      }

      const { id, ...newSale } = sale;
      await db.sales.add(newSale);
      mergedSales++;
    }

    for (const debt of (report.debts || [])) {
      const exists = debt.sale_uuid ? await db.debts.where('sale_uuid').equals(debt.sale_uuid).first() : null;
      if (!exists) {
        const { id, ...newDebt } = debt;
        await db.debts.add(newDebt);
        debtsMerged++;
      }
    }

    for (const sCust of (report.customers || [])) {
      const exists = await db.customers.where('phone').equals(sCust.phone).first();
      if (exists) {
        if (sCust.lastTransaction > exists.lastTransaction) {
          await db.customers.update(exists.id!, { 
            walletBalance: sCust.walletBalance, 
            lastTransaction: sCust.lastTransaction 
          });
        }
      } else {
        const { id, ...newCust } = sCust;
        await db.customers.add(newCust);
      }
    }
  });

  return { mergedSales, skippedSales, debtsMerged };
};

/**
 * FULL SYSTEM RESTORE (GZIP)
 */
export const restoreFullBackup = async (data: any) => {
  if (data.type !== 'MASTER_BACKUP') throw new Error("Invalid Master Backup file.");

  await clearAllData();

  await db.transaction('rw', [
    db.inventory, db.categories, db.customers, db.sales, 
    db.settings, db.security, db.users, db.expenses, 
    db.debts, db.stock_logs, db.parked_orders
  ], async () => {
    if (data.inventory) await db.inventory.bulkPut(data.inventory);
    if (data.categories) await db.categories.bulkPut(data.categories);
    if (data.customers) await db.customers.bulkPut(data.customers);
    if (data.sales) await db.sales.bulkPut(data.sales);
    if (data.settings) await db.settings.bulkPut(data.settings);
    if (data.security) await db.security.bulkPut(data.security);
    if (data.users) await db.users.bulkPut(data.users);
    if (data.expenses) await db.expenses.bulkPut(data.expenses);
    if (data.debts) await db.debts.bulkPut(data.debts);
    if (data.stock_logs) await db.stock_logs.bulkPut(data.stock_logs);
    if (data.parked_orders) await db.parked_orders.bulkPut(data.parked_orders);
  });

  const shopName = data.settings?.find((s: any) => s.key === 'shop_name')?.value;
  const licenseExp = data.security?.find((s: any) => s.key === 'license_expiry')?.value;
  if (shopName) localStorage.setItem('shop_name', shopName);
  if (licenseExp) {
    localStorage.setItem('license_expiry', licenseExp);
    localStorage.setItem('is_activated', 'true');
  }
  localStorage.setItem('is_setup_pending', 'false');
  
  return { success: true, shopName: shopName || 'Shop' };
};

/**
 * FIX: Added generateStaffInviteKey to resolve export error in Settings.tsx
 */
export const generateStaffInviteKey = async (staff: User) => {
  const sn = await db.settings.get('shop_name');
  const exp = await db.security.get('license_expiry');
  const sig = await db.security.get('license_signature');
  const bank = await db.settings.get('softPosBank');
  const accNum = await db.settings.get('softPosNumber');
  const accName = await db.settings.get('softPosAccount');
  const trialStart = await db.settings.get('trial_start');
  const shopCloudUuid = getShopId();

  const payload = {
    secret: 'NAIJA_VERIFIED',
    shopName: sn?.value || 'NaijaShop',
    shopCloudUuid,
    expiry: exp?.value || '',
    license_signature: sig?.value || '',
    trial_start: trialStart?.value || '',
    staffName: staff.name,
    staffPin: staff.pin,
    softPosBank: bank?.value || '',
    softPosNumber: accNum?.value || '',
    softPosAccount: accName?.value || '',
    boss_time: Date.now()
  };

  const key = btoa(JSON.stringify(payload));
  const url = `${window.location.origin}/join?key=${key}`;
  const message = `Hello ${staff.name}, Oga has invited you to manage ${payload.shopName}. \n\nClick this link on your phone to setup your terminal: ${url}`;

  if (navigator.share) {
    try {
      await navigator.share({
        title: `Invite for ${staff.name}`,
        text: message,
      });
    } catch (e) {
      window.open(`https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`, '_blank');
    }
  } else {
    window.open(`https://api.whatsapp.com/send?text=${encodeURIComponent(message)}`, '_blank');
  }
};

export const processStaffInvite = async (base64Key: string) => {
  try {
    const data = JSON.parse(atob(base64Key));
    if (data.secret !== 'NAIJA_VERIFIED') throw new Error("Invalid Invite Key");

    // Monotonic Check for Join process
    if (data.boss_time && Date.now() < (data.boss_time - (60 * 60 * 1000))) {
      alert("‚ö†Ô∏è CLOCK ERROR: Your phone date is incorrect. Please fix your phone time before joining.");
      return { success: false, error: "Incorrect Phone Date" };
    }

    // 1. CLEAR CURRENT LOCAL DATA FOR FRESH JOIN
    await clearAllData();

    // 2. APPLY THE CLOUD SILO ID FROM BOSS
    if (data.shopCloudUuid) {
      localStorage.setItem('shop_cloud_uuid', data.shopCloudUuid);
    }

    // 3. APPLY SHOP IDENTITY
    if (data.shopName) {
      await db.settings.put({ key: 'shop_name', value: data.shopName });
      localStorage.setItem('shop_name', data.shopName);
    }

    // 4. APPLY LICENSE (INHERIT BOSS ACTIVATION)
    if (data.expiry) {
      await db.security.put({ key: 'license_expiry', value: data.expiry });
      localStorage.setItem('license_expiry', data.expiry);
    }
    if (data.license_signature) {
      await db.security.put({ key: 'license_signature', value: data.license_signature });
      localStorage.setItem('license_signature', data.license_signature);
    }
    if (data.trial_start) {
      await db.settings.put({ key: 'trial_start', value: data.trial_start });
      localStorage.setItem('trial_start_date', String(data.trial_start));
    }
    
    localStorage.setItem('is_activated', 'true');
    localStorage.removeItem('is_trialing');

    // 5. APPLY SOFT POS SETTINGS
    if (data.softPosBank) await db.settings.put({ key: 'softPosBank', value: data.softPosBank });
    if (data.softPosNumber) await db.settings.put({ key: 'softPosNumber', value: data.softPosNumber });
    if (data.softPosAccount) await db.settings.put({ key: 'softPosAccount', value: data.softPosAccount });

    // 6. CREATE LOCAL USER FOR LOGIN
    await db.users.add({
      uuid: crypto.randomUUID(),
      name: data.staffName,
      pin: data.staffPin,
      role: 'Staff',
      last_updated: Date.now(),
      synced: 0
    });

    // 7. SET TERMINAL FLAGS
    localStorage.setItem('device_role', 'StaffDevice');
    localStorage.setItem('user_role', 'staff');
    localStorage.setItem('is_setup_pending', 'false');
    localStorage.setItem('isAuthenticated', 'false'); // Require login

    return { success: true, shopName: data.shopName };
  } catch (error) {
    console.error("Staff Invite Failed:", error);
    return { success: false, error: "Invalid Link" };
  }
};